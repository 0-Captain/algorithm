# 排序算法

## 算法种类

（全部为从小到大排序）

### 选择排序

每次选择数组剩余元素中最小的

特点：

- 运行时间与初始状态无关
- 数据移动最少

### 插入排序

类似于整理扑克牌，每拿起一张牌将其插入到手中有序牌堆中。实际操作时从数组头部开始，将右侧元素逐一插入到左侧有序数组中。为了给最小的元素腾出空间，左侧元素需要被移动。

特点：

- 所需时间取决于元素的初始顺序（适合接近有序的数组）
  - 数组中每个元素距离其最终位置都不远
  - 数组中只有几个元素位置不正确

### 希尔排序

希尔排序基于插入排序，在选择排序的基础上增加了一个递增序列[1::n], 对数组中所有间隔 n 的子数组先进行一次插入排序，然后不断降低 n 的值，直到 n 为 1，此时相当于直接进行插入排序。

虽然希尔排序相当于进行了多次插入排序，但是性能比插入排序要好得多，原因在于

1. 希尔排序可以加速元素的移动，例如要将一个元素从数组尾部移动到头部，在插入排序需要移动 N 次，而希尔排序可以利用递增序列大大加速这个过程。
2. 每进行一次插入排序，数组都更接近有序数组，有利于下一次插入排序。

特点：

- 算法的性能和递增序列关系较大

### 归并排序

归并排序主要思想是将两个有序数组合并为一个有序数组，实现过程中可以采用递归、分治的思想先将小数组处理为有序，然后合并小数组直到最后合并为一个数组。

### 快速排序

### 优先队列

## 复杂度分析

对排序来说，我们的研究对象是基于比较的算法，它们对数组元素的操作方式是由主键的比较决定的。一个基于比较的算法在两次比较之间可能会进行任意规模的计算。

对于长度为 N 的数组最多有 N!个排列，下图这个比较二叉树就包含了所有的比较情况，最坏情况下需要比较树高 h 次，所以算法的时间复杂度就是 h，根据二叉树的性质可以知道 N! < 叶子结点数量 < 2^h，所以 h > lgN!, 根据斯特灵公式 lgN! ~ N\*lgN，所以基于比较的排序算法性能上限就在 N\*lgN，这帮助我们明确了基于比较的排序算法的性能上限。

![](https://s2.loli.net/2022/02/09/N4m8QIcfK5dpTX2.jpg)

除了比较次数外，这些因素也对算法性能有影响：

1. 实践过程中不一定会遇到最坏情况（需要选择合适的算法）
2. 除了比较，算法的其他操作（访问数组）可能也有影响。
3. 不进行比较也能将某些数据排序

## 算法比较

#### 归并排序 vs 希尔排序

运行时间差距在常数级别。
